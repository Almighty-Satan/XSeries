package com.cryptomorin.xseries.profiles.skull;

import com.cryptomorin.xseries.profiles.PlayerProfileFetcherThread;
import com.cryptomorin.xseries.profiles.ProfileContainer;
import com.cryptomorin.xseries.profiles.Profileable;
import com.cryptomorin.xseries.profiles.ProfilesCore;
import com.cryptomorin.xseries.profiles.exceptions.InvalidProfileException;
import com.cryptomorin.xseries.profiles.exceptions.MojangAPIException;
import com.cryptomorin.xseries.profiles.exceptions.PlayerProfileNotFoundException;
import com.cryptomorin.xseries.profiles.exceptions.ProfileChangeException;
import com.mojang.authlib.GameProfile;
import org.bukkit.block.BlockState;
import org.bukkit.inventory.ItemStack;
import org.bukkit.inventory.meta.SkullMeta;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.CompletableFuture;

/**
 * Represents an instruction that sets a property of a {@link GameProfile}.
 * It uses a {@link #profileContainer} to define how to set the property and
 * a {@link #profileable} to define what to set in the property.
 *
 * @param <T> The type of the result produced by the {@link #profileContainer} function.
 */
public final class SkullInstruction<T> {
    /**
     * The function called that applies the given {@link #profileable} to an object that supports it
     * such as {@link ItemStack}, {@link SkullMeta} or a {@link BlockState}.
     */
    private final ProfileContainer<T> profileContainer;
    private Profileable profileable;
    private final List<Profileable> fallbacks = new ArrayList<>();

    private boolean lenient = false;

    protected SkullInstruction(ProfileContainer<T> profileContainer) {
        this.profileContainer = profileContainer;
    }

    /**
     * Removes the profile and skin texture.
     */
    public T removeProfile() {
        profileContainer.setProfile(null);
        return profileContainer.getObject();
    }

    /**
     * Fails silently if any string based issues occur from a configuration standpoint.
     * Mainly affects {@link Profileable#detect(String)}
     */
    public SkullInstruction<T> lenient() {
        this.lenient = true;
        return this;
    }

    public GameProfile getProfile() {
        return profileContainer.getProfile();
    }

    public String getProfileString() {
        return profileContainer.getProfileValue();
    }

    public SkullInstruction<T> profile(Profileable profileable) {
        this.profileable = profileable;
        return this;
    }

    public SkullInstruction<T> fallback(Profileable... fallbacks) {
        this.fallbacks.addAll(Arrays.asList(fallbacks));
        return this;
    }

    /**
     * Sets the profile generated by the instruction to the result type synchronously.
     * This is recommended if your code is already not on the main thread, or if you know
     * that the skull texture doesn't need additional requests.
     *
     * <h2>What are these additional requests?</h2>
     * This only applies to offline mode (cracked) servers. Since these servers use
     * a cracked version of the player UUIDs and not their real ones, the real UUID
     * needs to be known by requesting it from Mojang servers and this request which
     * requires internet connection, will delay things a lot.
     *
     * @return The result after setting the generated profile.
     */
    public T apply() {
        Objects.requireNonNull(profileable, "No profile was set");
        ProfileChangeException exception = null;

        List<Profileable> tries = new ArrayList<>(1 + fallbacks.size());
        tries.add(profileable);
        tries.addAll(fallbacks);

        boolean success = false;
        for (Profileable profileable : tries) {
            try {
                GameProfile profile = profileable.getProfile();
                profileContainer.setProfile(profile);
                success = true;
                break;
            } catch (PlayerProfileNotFoundException | MojangAPIException | InvalidProfileException ex) {
                if (exception == null) {
                    exception = new ProfileChangeException("Could not set the profile for " + profileContainer);
                }
                exception.addSuppressed(ex);
            }
        }

        if (exception != null) {
            if (success || lenient) ProfilesCore.debug("apply()", exception);
            else throw exception;
        }

        return profileContainer.getObject();
    }

    /**
     * Asynchronously applies the instruction to generate a {@link GameProfile} and returns a {@link CompletableFuture}.
     * This method is designed for non-blocking execution, allowing tasks to be performed
     * in the background without blocking the server's main thread.
     * This method will always execute async, even if the results are cached.
     * <p>
     * <h2>Reference Issues</h2>
     * Note that while these methods apply to the item/block instances, passing these instances
     * to certain methods, for example {@link org.bukkit.inventory.Inventory#setItem(int, ItemStack)}
     * will create a NMS copy of that instance and use that instead. Which means if for example
     * you're going to be using an item for an inventory, you'd have to set the item again
     * manually to the inventory once this method is done.
     * <pre>{@code
     * Inventory inventory = ...;
     * XSkull.createItem().profile(player).applyAsync()
     *     .thenAcceptAsync(item -> inventory.setItem(slot, item));
     * }</pre>
     *
     * <h2>Usage example:</h2>
     * <pre>{@code
     *   XSkull.createItem().profile(player).applyAsync()
     *      .thenAcceptAsync(result -> {
     *          // Additional processing...
     *      }, runnable -> Bukkit.getScheduler().runTask(plugin, runnable));
     * }</pre>
     *
     * @return A {@link CompletableFuture} that will complete asynchronously.
     */
    public CompletableFuture<T> applyAsync() {
        return CompletableFuture.supplyAsync(this::apply, PlayerProfileFetcherThread.EXECUTOR);
    }
}